/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

/**
 * Package for deploying to JS and other platforms (like C#) for third-party use (besides Flash)
 * @author Glidias
 */
export class altern {
	protected constructor();
}

export namespace components {
	/**
	 * ...
	 * @author Glenn Ko
	 */
	export class Transform3D {
		constructor();
		a: number;
		b: number;
		c: number;
		d: number;
		e: number;
		f: number;
		g: number;
		h: number;
		i: number;
		j: number;
		k: number;
		l: number;
		identity(): void;
		compose(x: number, y: number, z: number, rotationX: number, rotationY: number, rotationZ: number, scaleX: number, scaleY: number, scaleZ: number): void;
		invert(): void;
		initFromVector(vector: number[]): void;
		append(transform: components.Transform3D): void;
		prepend(transform: components.Transform3D): void;
		combine(transformA: components.Transform3D, transformB: components.Transform3D): void;
		calculateInversion(source: components.Transform3D): void;
		copy(source: components.Transform3D): void;
	}
}

export namespace util.geom {
	export class Mat3 implements util.geom.IMat3 {
		constructor(a: number, b?: number, c?: number, e?: number, f?: number, g?: number, i?: number, j?: number, k?: number);
		a: number;
		b: number;
		c: number;
		e: number;
		f: number;
		g: number;
		i: number;
		j: number;
		k: number;
		determinant(): number;
		identity(): void;
		clone(): util.geom.Mat3;
		transformVector(vin: util.geom.Vec3, vout: util.geom.Vec3): void;
		transformVectorTransposed(vin: util.geom.Vec3, vout: util.geom.Vec3): void;
		transformVec3To3D(vin: util.geom.Vec3, vout: util.geom.Vec3): void;
		invert(): void;
		invert_with_determinant(det: number): void;
		append(m: util.geom.Mat3): void;
		prepend(m: util.geom.Mat3): void;
		prependTransposed(m: util.geom.Mat3): void;
		add(m: util.geom.Mat3): void;
		subtract(m: util.geom.Mat3): void;
		transpose(): void;
		toSkewSymmetric(v: util.geom.Vec3): void;
		copyFrom(m: util.geom.Mat3): void;
		writeToEulerAngles(angles: util.geom.Vec3): void;
		setRotation(rx: number, ry: number, rz: number): void;
		setFromAxisAngle(axis: util.geom.Vec3, angle: number): void;
		toString(): string;
		static IDENTITY: util.geom.Mat3;
		static ZERO: util.geom.Mat3;
	}
}

export namespace util.geom {
	export class Mat4 implements util.geom.IMat4 {
		constructor(a: number, b?: number, c?: number, d?: number, e?: number, f?: number, g?: number, h?: number, i?: number, j?: number, k?: number, l?: number);
		a: number;
		b: number;
		c: number;
		d: number;
		e: number;
		f: number;
		g: number;
		h: number;
		i: number;
		j: number;
		k: number;
		l: number;
		identity(): void;
		determinant(): number;
		invert(): void;
		invert_with_determinant(det: number): void;
		append(m: util.geom.Mat4): void;
		prepend(m: util.geom.Mat4): void;
		add(m: util.geom.Mat4): void;
		subtract(m: util.geom.Mat4): void;
		transformPoint(vin: util.geom.Vec3, vout: util.geom.Vec3): void;
		transformPointTransposed(vin: util.geom.Vec3, vout: util.geom.Vec3): void;
		transformPoints(arrin: util.geom.Vec3[], arrout: util.geom.Vec3[]): void;
		transformPointsN(arrin: util.geom.Vec3[], arrout: util.geom.Vec3[], len: number): void;
		transformPointsTransposed(arrin: util.geom.Vec3[], arrout: util.geom.Vec3[]): void;
		transformPointsTransposedN(arrin: util.geom.Vec3[], arrout: util.geom.Vec3[], len: number): void;
		getAxis(idx: number, axis: util.geom.Vec3): void;
		setAxes(xAxis: util.geom.Vec3, yAxis: util.geom.Vec3, zAxis: util.geom.Vec3, pos: util.geom.Vec3): void;
		transformVector(vin: util.geom.Vec3, vout: util.geom.Vec3): void;
		transformVectorTransposed(vin: util.geom.Vec3, vout: util.geom.Vec3): void;
		copy(m: util.geom.Mat4): void;
		copy3(m: util.geom.Mat3): void;
		getEulerAngles(angles: util.geom.Vec3): void;
		setPosition(pos: util.geom.Vec3): void;
		setPositionXYZ(x: number, y: number, z: number): void;
		clone(): util.geom.Mat4;
		toString(): string;
		setRotation(rx: number, ry: number, rz: number): void;
		setFromAxisAngle(axis: util.geom.Vec3, angle: number): void;
		static IDENTITY: util.geom.Mat4;
	}
}

export namespace util.geom {
	export class Vec3 {
		constructor(x: number, y?: number, z?: number);
		x: number;
		y: number;
		z: number;
		length(): number;
		lengthSqr(): number;
		dotProduct(v: util.geom.Vec3): number;
		crossProduct(v: util.geom.Vec3): util.geom.Vec3;
		clone(): util.geom.Vec3;
		isZeroVector(): boolean;
		crossProductSet(v: util.geom.Vec3): void;
		add(v: util.geom.Vec3): void;
		addScaled(k: number, v: util.geom.Vec3): void;
		subtract(v: util.geom.Vec3): void;
		sum(a: util.geom.Vec3, b: util.geom.Vec3): void;
		diff(a: util.geom.Vec3, b: util.geom.Vec3): void;
		scale(k: number): void;
		reverse(): void;
		transform3(m: util.geom.Mat3): void;
		transformTransposed3(m: util.geom.Mat3): void;
		reset(): void;
		set(param1: number, param2: number, param3: number): void;
		saveTo(result: util.geom.Vec3): void;
		copyFrom(source: util.geom.Vec3): void;
		transform4(m: util.geom.Mat4): void;
		transformTransposed4(m: util.geom.Mat4): void;
		transformVector4(m: util.geom.Mat4): void;
		assignAddition(v1: util.geom.Vec3, v2: util.geom.Vec3): void;
		normalize(): void;
		setLength(val: number): void;
		removeComponent(axis: util.geom.Vec3): void;
		distanceTo(v: util.geom.Vec3): number;
		toString(): string;
		static ZERO: util.geom.Vec3;
		static X_AXIS: util.geom.Vec3;
		static Y_AXIS: util.geom.Vec3;
		static Z_AXIS: util.geom.Vec3;
		static RIGHT: util.geom.Vec3;
		static LEFT: util.geom.Vec3;
		static FORWARD: util.geom.Vec3;
		static BACK: util.geom.Vec3;
		static UP: util.geom.Vec3;
		static DOWN: util.geom.Vec3;
		static copy(v: util.geom.Vec3): util.geom.Vec3;
		static createCross(v1: util.geom.Vec3, v2: util.geom.Vec3): util.geom.Vec3;
		static createAdd(v1: util.geom.Vec3, v2: util.geom.Vec3): util.geom.Vec3;
		static createSubtract(v1: util.geom.Vec3, v2: util.geom.Vec3): util.geom.Vec3;
		static createScale(v: util.geom.Vec3, scaleAmt: any): util.geom.Vec3;
		static createProjection(v: util.geom.Vec3, axis: util.geom.Vec3): util.geom.Vec3;
		static dot(v1: util.geom.Vec3, v2: util.geom.Vec3): number;
		static lengthOf(v: util.geom.Vec3): number;
		static squareLengthOf(v: util.geom.Vec3): number;
		static writeCross(v1: util.geom.Vec3, v2: util.geom.Vec3, output: util.geom.Vec3): void;
		static writeProjection(v: util.geom.Vec3, axis: util.geom.Vec3, output: util.geom.Vec3): void;
		static writeSubtract(output: util.geom.Vec3, input: util.geom.Vec3): void;
		static writeAdd(output: util.geom.Vec3, input: util.geom.Vec3): void;
		static writeScale(output: util.geom.Vec3, scaleAmt: number): void;
	}
}

export namespace systems.collisions {
	export class CollisionEvent {
		constructor();
		pos: util.geom.Vec3;
		offset: number;
		normal: util.geom.Vec3;
		t: number;
		geomtype: number;
		dest: util.geom.Vec3;
		next: systems.collisions.CollisionEvent;
		getNumEvents(): number;
		write(pos: util.geom.Vec3, normal: util.geom.Vec3, offset: number, t: number, dest: util.geom.Vec3, geomtype: number): void;
		calcFallbackPosition(radiusX: number, radiusY: number, radiusZ: number, resultPosition: util.geom.Vec3): void;
		dispose(): void;
		static readonly GEOMTYPE_POINT: number;
		static readonly GEOMTYPE_EDGE: number;
		static readonly GEOMTYPE_POLYGON: number;
		static readonly GEOMTYPE_THING: number;
		static readonly TOLERANCE_POLYGON_OVERLAP: number;
		static readonly TOLERANCE_BACKWARDS_T: number;
		static readonly TOLERANCE_TRANSVERSE_DISPLACEMENT: number;
		static readonly TOLERANCE_QUADRATIC_DISCRIMINANT: number;
		static COLLECTOR: systems.collisions.CollisionEvent;
		static Get(collision: util.geom.Vec3, normal: util.geom.Vec3, offset: number, t: number, dest: util.geom.Vec3, geomtype: number): systems.collisions.CollisionEvent;
		static GetAs3(pos: altern.Vector3D, normal: altern.Vector3D, offset: number, t: number, dest: altern.Vector3D, geomtype: number): systems.collisions.CollisionEvent;
		static get(pos: util.geom.Vec3, normal: util.geom.Vec3, offset: number, t: number, dest: util.geom.Vec3, geomtype: number): systems.collisions.CollisionEvent;
		static getGeomTypeString(type: number): string;
	}
}

export namespace systems.collisions {
	/**
	 * ...
	 * @author Glenn Ko
	 */
	export interface IECollidable {
		collectGeometry(collider: systems.collisions.EllipsoidCollider): void;
	}
}

export namespace systems.collisions {
	/**
	 * The class implements the algorithm of the continuous collision of an ellipsoid with the faces.
	 */
	export class EllipsoidCollider {
		/**
		 * Creates a EllipsoidCollider object.
		 *
		 *  @param radiusX Ellipsoid radius along X axis.
		 * @param radiusY Ellipsoid radius along Y axis.
		 * @param radiusZ Ellipsoid radius along Z axis.
		 */
		constructor(radiusX: number, radiusY: number, radiusZ: number, threshold?: number, requireEvents?: boolean);
		/**
		 * Ellipsoid radius along X axis.
		 */
		radiusX: number;
		/**
		 * Ellipsoid radius along Y axis.
		 */
		radiusY: number;
		/**
		 * Ellipsoid radius along Z axis.
		 */
		radiusZ: number;
		/**
		 * Geometric error. Minimum absolute difference between two values
		 * when they are considered to be different. Default value is 0.001.
		 */
		threshold: number;
		matrix: components.Transform3D;
		inverseMatrix: components.Transform3D;
		vertices: number[];
		normals: number[];
		indices: number[];
		readonly numFaces: number;
		readonly numI: number;
		/**
		 * @private
		 */
		sphere: altern.Vector3D;
		timestamp: number;
		collisions: systems.collisions.CollisionEvent;
		/**
		 * @private
		 */
		calculateSphere(transform: components.Transform3D): void;
		calculateCollidableGeometry(source: altern.Vector3D, collidable: systems.collisions.IECollidable): void;
		addGeometry(geometry: util.geom.Geometry, transform: components.Transform3D): void;
		/**
		 * Calculates destination point from given start position and displacement vector.
		 * @param source Starting point.
		 * @param displacement Displacement vector.
		 * @param collidable An IECollidable implementation responsible for collecting geometry for this instance.
		 * @param timeFrame	 A timeframe used to add t into each collision event (if collision events are enabled)
		 * @return Destination point.
		 */
		calculateDestination(source: altern.Vector3D, displacement: altern.Vector3D, collidable: systems.collisions.IECollidable, timeFrame?: number, fromTime?: number): altern.Vector3D;
		/**
		 * Finds first collision from given starting point aling displacement vector.
		 * @param source Starting point.
		 * @param displacement Displacement vector.
		 * @param resCollisionPoint Collision point will be written into this variable.
		 * @param resCollisionPlane Collision plane (defines by normal) parameters will be written into this variable.
		 * @param collidable The object to use in collision detection. If a container is specified, all its children will be tested for collison with ellipsoid.
		 * @param excludedObjects An associative array whose keys are instances of <code>Object3D</code> and its children.
		 * @return <code>true</code> if collision detected and <code>false</code> otherwise.
		 */
		getCollision(source: altern.Vector3D, displacement: altern.Vector3D, resCollisionPoint: altern.Vector3D, resCollisionPlane: altern.Vector3D, collidable: systems.collisions.IECollidable): boolean;
	}
}

export namespace systems.collisions {
	/**
	 * ...
	 * @author Glenn Ko
	 */
	export interface IECollidable {
		collectGeometry(collider: systems.collisions.EllipsoidCollider): void;
	}
}

export namespace systems.collisions {
	/**
	 * ...
	 * @author Glenn Ko
	 */
	export interface ITCollidable {
		collectGeometryAndTransforms(collider: systems.collisions.EllipsoidCollider, baseTransform: components.Transform3D): void;
	}
}

export namespace altern.ray {
	/**
	 * @author Glidias
	 */
	export interface IRaycastImpl {
		/**
		 * The implementation for this interface is highly app-specific and not meant to be user friendly.
		 * Most end users would simply use an altern.ray.Raycaster utility class instance to manage all raycasts from a specific starting source, and also handles some further boilerplate to get raycast position in global space (and any extra data) for it if the user so requires.
		 *
		 * @param	origin	The starting position of the ray in local coordinate space of receiving object.
		 * @param	direction	The direction vector of ray in local coordinate space of receiving object. The "w" component of the direction vector, if set to a non-zero value, imples a default ignore-beyond "clamp" length. This means the raycast distance must be LOWER (<) than the given clamp length in order to trigger a "hit". Any objects that lie above or equal (>=) to the given clamp distance, is missed completely.
		 * @param	output	The output vector to use. Under normal use, remember to reset the output.w value to zero for every new raycast source raycast  (or create a fresh new vector each time)! If set to a non-zero value, will treat the output.w as the current clamp length, instead of direction.w!
		 * @return	If "hit", returns the same output Vector3D whose "w" component is updated (including local hit position).
		 */
		intersectRay(origin: altern.Vector3D, direction: altern.Vector3D, output: altern.Vector3D): altern.Vector3D;
	}
}

export namespace components {
	/**
	 * Class stores object's bounding box object's local space. Generally, position of child objects isn't considered at BoundBox calculation.
	 * Ray intersection always made  boundBox check at first, but it's possible to check on crossing  boundBox  only.
	 *
	 */
	export class BoundBox implements util.geom.IAABB {
		constructor();
		minX: number;
		minY: number;
		minZ: number;
		maxX: number;
		maxY: number;
		maxZ: number;
	}
}

export namespace altern.collisions {
	/**
	 * A CollisionBoundNode can be formed as part of a hierachial transformed (optional)OOBB tree of nodes, and can contain
	 * optional collidable/raycasting implementations within each node. Useful to set up any collision/raycastable scene graph accordingly.
	 * @author Glidias
	 */
	export class CollisionBoundNode implements systems.collisions.IECollidable {
		protected constructor();
		childrenList: altern.collisions.CollisionBoundNode;
		next: altern.collisions.CollisionBoundNode;
		_parent: altern.collisions.CollisionBoundNode;
		transform: components.Transform3D;
		inverseTransform: components.Transform3D;
		localToGlobalTransform: components.Transform3D;
		globalToLocalTransform: components.Transform3D;
		calculateLocalGlobalTransforms(): void;
		collidable: systems.collisions.ITCollidable;
		raycastable: altern.ray.IRaycastImpl;
		boundBox: components.BoundBox;
		localToWorldTransform: components.Transform3D;
		worldToLocalTransform: components.Transform3D;
		calculateLocalWorldTransforms(): void;
		/**
		 * Creates a mirror clone of the current collision bound node and all it's descendents
		 * (ie. cloning the entire hierachy). Bounding boxes/local transforms/addons are shared between mirror clones except for the
		 * hierachy itself and localToGlobalTransform/globalToLocalTransform caches.
		 * @return
		 */
		mirrorClone(): altern.collisions.CollisionBoundNode;
		/**
		 * Updates current transform with a reference transform
		 * @param	refTransform	The reference transform to match
		 */
		updateTransform(refTransform: components.Transform3D): void;
		collectGeometry(collider: systems.collisions.EllipsoidCollider): void;
		intersectRay(origin: altern.Vector3D, direction: altern.Vector3D, output: altern.Vector3D): altern.Vector3D;
		addChild(child: altern.collisions.CollisionBoundNode): altern.collisions.CollisionBoundNode;
		removeChild(child: altern.collisions.CollisionBoundNode): altern.collisions.CollisionBoundNode;
		static calculateLocalToGlobal2(obj: altern.collisions.CollisionBoundNode, trm?: components.Transform3D): components.Transform3D;
		static calculateGlobalToLocal2(obj: altern.collisions.CollisionBoundNode, trm?: components.Transform3D): components.Transform3D;
		/**
		 * Creates a brand new minimal CollisionBoundNode instance with an already (assumed usually precalculated) transform instance and an optional (assumed already precalculated)  inverseTransform instance.
		 * @param	transform	The  (usually precalculated) transform to assign
		 * @param	inverseTransform	(optoinal) The precalculated inverseTransform to assign
		 * @return
		 */
		static create(transform: components.Transform3D, inverseTransform?: components.Transform3D): altern.collisions.CollisionBoundNode;
		static createNew(transform: components.Transform3D, inverseTransform?: components.Transform3D, collidable?: systems.collisions.ITCollidable, raycastable?: altern.ray.IRaycastImpl): altern.collisions.CollisionBoundNode;
	}
}

export namespace util.geom {
	/**
	 * ...
	 * @author Glidias
	 */
	export interface XYZW {
		x: number;
		y: number;
		z: number;
		w: number;
	}
}

export namespace altern {
	export class Vector3D implements util.geom.XYZW {
		constructor(x: number, y?: number, z?: number, w?: number);
		get_length(): number;
		get_lengthSquared(): number;
		w: number;
		x: number;
		y: number;
		z: number;
		add(a: altern.Vector3D): altern.Vector3D;
		clone(): altern.Vector3D;
		crossProduct(a: altern.Vector3D): altern.Vector3D;
		decrementBy(a: altern.Vector3D): void;
		dotProduct(a: altern.Vector3D): number;
		equals(toCompare: altern.Vector3D, allFour?: boolean): boolean;
		incrementBy(a: altern.Vector3D): void;
		nearEquals(toCompare: altern.Vector3D, tolerance: number, allFour?: boolean): boolean;
		negate(): void;
		normalize(): number;
		project(): void;
		scaleBy(s: number): void;
		subtract(a: altern.Vector3D): altern.Vector3D;
		toString(): string;
		static angleBetween(a: altern.Vector3D, b: altern.Vector3D): number;
		static distance(pt1: altern.Vector3D, pt2: altern.Vector3D): number;
		static get_X_AXIS(): altern.Vector3D;
		static get_Y_AXIS(): altern.Vector3D;
		static get_Z_AXIS(): altern.Vector3D;
	}
}

export namespace altern.ray {
	/**
	 * @author Glidias
	 */
	export interface IRaycastImpl {
		/**
		 * The implementation for this interface is highly app-specific and not meant to be user friendly.
		 * Most end users would simply use an altern.ray.Raycaster utility class instance to manage all raycasts from a specific starting source, and also handles some further boilerplate to get raycast position in global space (and any extra data) for it if the user so requires.
		 *
		 * @param	origin	The starting position of the ray in local coordinate space of receiving object.
		 * @param	direction	The direction vector of ray in local coordinate space of receiving object. The "w" component of the direction vector, if set to a non-zero value, imples a default ignore-beyond "clamp" length. This means the raycast distance must be LOWER (<) than the given clamp length in order to trigger a "hit". Any objects that lie above or equal (>=) to the given clamp distance, is missed completely.
		 * @param	output	The output vector to use. Under normal use, remember to reset the output.w value to zero for every new raycast source raycast  (or create a fresh new vector each time)! If set to a non-zero value, will treat the output.w as the current clamp length, instead of direction.w!
		 * @return	If "hit", returns the same output Vector3D whose "w" component is updated (including local hit position).
		 */
		intersectRay(origin: altern.Vector3D, direction: altern.Vector3D, output: altern.Vector3D): altern.Vector3D;
	}
}

export namespace systems.collisions {
	/**
	 * ...
	 * @author Glenn Ko
	 */
	export interface ITCollidable {
		collectGeometryAndTransforms(collider: systems.collisions.EllipsoidCollider, baseTransform: components.Transform3D): void;
	}
}

export namespace altern.collisions.dbvt {
	/**
	 * @author Glidias
	 */
	export class DBVTProxy {
		constructor();
		raycastable: altern.ray.IRaycastImpl;
		collidable: systems.collisions.ITCollidable;
		transform: components.Transform3D;
		inverseTransform: components.Transform3D;
		localToGlobalTransform: components.Transform3D;
		globalToLocalTransform: components.Transform3D;
	}
}

export namespace altern.collisions.dbvt {
	/**
	 * A node of the dynamic bounding volume tree.
	 * @author saharan
	 */
	export class DBVTNode {
		constructor();
		/**
		 * The first child node of this node.
		 */
		child1: altern.collisions.dbvt.DBVTNode;
		/**
		 * The second child node of this node.
		 */
		child2: altern.collisions.dbvt.DBVTNode;
		/**
		 * The parent node of this tree.
		 */
		parent: altern.collisions.dbvt.DBVTNode;
		/**
		 * The proxy of this node. This has no value if this node is not leaf.
		 */
		proxy: altern.collisions.dbvt.DBVTProxy;
		/**
		 * The maximum distance from leaf nodes.
		 */
		height: number;
		/**
		 * The AbstractAABB of this node.
		 */
		aabb: components.BoundBox;
		static createFrom(obj: any, aabb: components.BoundBox, transform?: components.Transform3D): altern.collisions.dbvt.DBVTNode;
	}
}

export namespace altern.collisions.dbvt {
	/**
	 * A dynamic bounding volume tree for the broad-phase algorithm.
	 * @author saharan
	 */
	export class DBVT implements altern.ray.IRaycastImpl, systems.collisions.ITCollidable {
		constructor();
		/**
		 * The root of the tree.
		 */
		root: altern.collisions.dbvt.DBVTNode;
		purge(): void;
		/**
		 * Move a leaf.
		 * @param	leaf
		 */
		moveLeaf(leaf: altern.collisions.dbvt.DBVTNode): void;
		/**
		 * Insert a leaf to the tree.
		 * @param	node
		 */
		insertLeaf(leaf: altern.collisions.dbvt.DBVTNode): void;
		getBalance(node: altern.collisions.dbvt.DBVTNode): number;
		/**
		 * Delete a leaf from the tree.
		 * @param	node
		 */
		deleteLeaf(leaf: altern.collisions.dbvt.DBVTNode): void;
		collectGeometryAndTransforms(collider: systems.collisions.EllipsoidCollider, baseTransform: components.Transform3D): void;
		intersectRay(origin: altern.Vector3D, direction: altern.Vector3D, output: altern.Vector3D): altern.Vector3D;
	}
}

export namespace altern.culling {
	/**
	 * Generic Culling DFS recursion utility
	 * @author Glidias
	 */
	export class CullingDFS {
		constructor();
		initialCulling: number;
		checkBoundBox: (arg0: components.BoundBox, arg1: number, arg2: altern.collisions.CollisionBoundNode) => number;
		checkChild: (arg0: altern.collisions.CollisionBoundNode, arg1: number) => boolean;
		processWorldToLocal: (arg0: components.Transform3D, arg1: altern.collisions.CollisionBoundNode) => void;
		processLocalToWorld: (arg0: components.Transform3D, arg1: altern.collisions.CollisionBoundNode) => void;
		processChild: (arg0: altern.collisions.CollisionBoundNode, arg1: number) => boolean;
		purge(): void;
		start(): boolean;
	}
}

export namespace altern.culling {
	/**
	 * ...
	 * @author Glidias
	 */
	export class CullingPlane {
		constructor();
		x: number;
		y: number;
		z: number;
		offset: number;
		next: altern.culling.CullingPlane;
		static collector: altern.culling.CullingPlane;
		static create(): altern.culling.CullingPlane;
	}
}

export namespace altern.terrain {
	/**
	 * @author Glidias
	 */
	export interface ICuller {
		/**
		 * @param	culling A value higher than zero is reccomended for testing bounds against required frustum planes
		 * @return	Resultant culling bitmask value. ( 1=near, 2=far, 4=left, 8=right, 16=top, 32=bottom) where bound intersection occurs.
		 * 			A value of -1 bounds completely outside camera view. A value of zero indicates bounds completely within camera view.
		 */
		cullingInFrustum(culling: number, boundMinX: number, boundMinY: number, boundMinZ: number, boundMaxX: number, boundMaxY: number, boundMaxZ: number): number;
	}
}

export namespace altern.geom {
	/**
	 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 * If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.
	 * You may add additional accurate notices of copyright ownership.
	 *
	 * It is desirable to notify that Covered Software was "Powered by AlternativaPlatform" with link to http://www.alternativaplatform.com/
	 *
	 */
	export class Vertex {
		constructor();
		next: altern.geom.Vertex;
		value: altern.geom.Vertex;
		x: number;
		y: number;
		z: number;
		offset: number;
		temp: boolean;
		cameraX: number;
		cameraY: number;
		cameraZ: number;
		transformId: number;
		static collector: altern.geom.Vertex;
		static create(): altern.geom.Vertex;
	}
}

export namespace altern.geom {
	/**
	 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 * If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.
	 * You may add additional accurate notices of copyright ownership.
	 *
	 * It is desirable to notify that Covered Software was "Powered by AlternativaPlatform" with link to http://www.alternativaplatform.com/
	 *
	 */
	export class Wrapper {
		constructor();
		next: altern.geom.Wrapper;
		vertex: altern.geom.Vertex;
		static collector: altern.geom.Wrapper;
		static create(): altern.geom.Wrapper;
	}
}

export namespace altern.geom {
	/**
	 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 * If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.
	 * You may add additional accurate notices of copyright ownership.
	 *
	 * It is desirable to notify that Covered Software was "Powered by AlternativaPlatform" with link to http://www.alternativaplatform.com/
	 *
	 */
	export class Face {
		constructor();
		next: altern.geom.Face;
		processNext: altern.geom.Face;
		normalX: number;
		normalY: number;
		normalZ: number;
		offset: number;
		wrapper: altern.geom.Wrapper;
		visible: boolean;
		collect(): void;
		destroy(): void;
		calculateNormal(): void;
		calculateBestSequenceAndNormal(): void;
		getArea(): number;
		overlapsOther2D(face: altern.geom.Face): boolean;
		isPointInside2D(centerX: number, centerY: number): boolean;
		static collector: altern.geom.Face;
		static create(): altern.geom.Face;
		/**
		 *
		 * @param	pos Center position of quad
		 * @param	up	The normalised up vector
		 * @param	right	The normalised right vector
		 * @param	halfWidth	The (half-offset)width from center position
		 * @param	halfHeight	The (half-offset)height from center position
		 * @param	t	The transform to use
		 * @return	A single quad face
		 */
		static getQuad(pos: util.geom.Vec3, up: util.geom.Vec3, right: util.geom.Vec3, halfWidth: number, halfHeight: number, t: components.Transform3D): altern.geom.Face;
		static setupQuad(f: altern.geom.Face, pos: util.geom.Vec3, up: util.geom.Vec3, right: util.geom.Vec3, halfWidth: number, halfHeight: number, t: components.Transform3D): altern.geom.Face;
	}
}

export namespace altern.culling {
	/**
	 * ...
	 * @author Glidias
	 */
	export class DefaultCulling implements altern.terrain.ICuller {
		constructor();
		frustum: altern.culling.CullingPlane;
		cullingInFrustum(culling: number, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): number;
		static cullingInFrustumOf(frustum: altern.culling.CullingPlane, culling: number, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): number;
		static isInFrontOfFrustum(ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number, frustumCorners: altern.Vector3D[]): boolean;
		static clippedFace: altern.geom.Face;
		static collectClippedFace(): void;
		static clippedFace2: altern.geom.Face;
		static collectClippedFace2(): void;
		static CLIP_NEAR: boolean;
		static triInFrustumCover(frustum: altern.culling.CullingPlane, ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number): number;
		static pointInFrustum(frustum: altern.culling.CullingPlane, x: number, y: number, z: number): boolean;
	}
}

export namespace altern.geom {
	/**
	 * Utility to help calculate trajecotry-based intersections along 3d tri-slopes.
	 * @author Glenn Ko
	 */
	export class IntersectSlopeUtil {
		constructor();
		startPt: altern.Vector3D;
		endPt: altern.Vector3D;
		pt2: altern.Vector3D;
		pt1: altern.Vector3D;
		pt3: altern.Vector3D;
		velocity: altern.Vector3D;
		startPosition: altern.Vector3D;
		intersectSides: number[];
		intersectTimes: Float32Array;
		intersectZ: Float32Array;
		gradient: number;
		_unitDist: number;
		sqDistBetween2DVector(a: altern.Vector3D, b: altern.Vector3D): number;
		rBetween2DVec(a: altern.Vector3D, b: altern.Vector3D, c: altern.Vector3D): number;
		setupRay(origin: altern.Vector3D, direction: altern.Vector3D): void;
		getTriSlopeTrajTime(direction: altern.Vector3D, gravity: number, strength: number): number;
		setupTri(ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number): void;
		getTrajHeightAtTime(velocity: altern.Vector3D, gravity: number, t: number): number;
		getTrajHeightAtTime2(direction: altern.Vector3D, gravity: number, strength: number, t: number): number;
		getGradHeightAtTime(t: number): number;
		getFlatTrajTime(direction: altern.Vector3D, gravity: number, strength: number, grad?: number): number;
		getTriIntersections(): number;
		IsIntersecting(a: altern.Vector3D, b: altern.Vector3D, c: altern.Vector3D, d: altern.Vector3D): boolean;
		static readonly RESULT_NONE: number;
		static readonly RESULT_SLOPE: number;
		static readonly RESULT_WALL: number;
		static readonly RESULT_COLLINEAR: number;
		static readonly RESULT_COLLINEAR_VALID: number;
		static readonly RESULT_ERROR: number;
	}
}

export namespace altern.culling {
	/**
	 * @author Glidias
	 */
	export interface IFrustumCollectTri {
		collectTrisForFrustum(frustum: altern.culling.CullingPlane, culling: number, frustumCorners: altern.Vector3D[], vertices: number[], indices: number[]): void;
	}
}

export namespace altern.partition.js {
	/**
	 * ...
	 * @author Glidias
	 */
	export class BVHTree implements altern.culling.IFrustumCollectTri, altern.ray.IRaycastImpl, systems.collisions.ITCollidable {
		constructor(bvh: bvhtree.BVH);
		setBufferAlloc(amt: number): void;
		collectGeometryFromAABB(aabb: components.BoundBox): util.geom.Geometry;
		collectGeometryAndTransforms(collider: systems.collisions.EllipsoidCollider, baseTransform: components.Transform3D): void;
		purge(): void;
		intersectRay(origin: altern.Vector3D, direction: altern.Vector3D, output: altern.Vector3D): altern.Vector3D;
		collectTrisForFrustum(frustum: altern.culling.CullingPlane, culling: number, frustumCorners: altern.Vector3D[], vertices: number[], indices: number[]): void;
	}
}

export namespace altern.ray {
	/**
	 * Utility helper class instance to handle "meaningful"/straightforward raycasting for end-user.
	 * syntax eg.
	 * var myRaycaster = new Raycaster();
	 * var hitTest = myRaycaster.positionAndDirection(x, y, z, dx, dy, dz).gotHit();
	 * if (hitTest != null) {
	 * 	// do hit resolution
	 * }
	 * @author Glidias
	 */
	export class Raycaster {
		/**
		 * @param	source   Assign a starting target source for the given Raycaster implementing IRaycastImpl.
		 */
		constructor(source: altern.ray.IRaycastImpl);
		source: altern.ray.IRaycastImpl;
		setTarget(source: altern.ray.IRaycastImpl): altern.ray.Raycaster;
		position(x: number, y: number, z: number): altern.ray.Raycaster;
		direction(x: number, y: number, z: number): altern.ray.Raycaster;
		positionAndDirection(x: number, y: number, z: number, dx: number, dy: number, dz: number): altern.ray.Raycaster;
		/**
		 *
		 * @param	dist	Set to zero to not have any distance clamp consideration. Otherwise, any distance greater or equal to this parameter will not be raycasted/recorded as a hit!
		 */
		setIgnoreDistance(dist: number): void;
		gotHit(): altern.Vector3D;
	}
}

export namespace haxe._Int64 {
	export class ___Int64 {
		constructor(high: number, low: number);
		high: number;
		low: number;
		/**
		 * We also define toString here to ensure we always get a pretty string
		 * when tracing or calling Std.string. This tends not to happen when
		 * toString is only in the abstract.
		 */
		toString(): string;
	}
}

export namespace haxe.io {
	export class Bytes {
		protected constructor(data: ArrayBuffer);
		readonly length: number;
		get(pos: number): number;
		set(pos: number, v: number): void;
		blit(pos: number, src: haxe.io.Bytes, srcpos: number, len: number): void;
		fill(pos: number, len: number, value: number): void;
		sub(pos: number, len: number): haxe.io.Bytes;
		compare(other: haxe.io.Bytes): number;
		/**
		 * Returns the IEEE double precision value at given position (in low endian encoding).
		 * Result is unspecified if reading outside of the bounds
		 */
		getDouble(pos: number): number;
		/**
		 * Returns the IEEE single precision value at given position (in low endian encoding).
		 * Result is unspecified if reading outside of the bounds
		 */
		getFloat(pos: number): number;
		/**
		 * Store the IEEE double precision value at given position in low endian encoding.
		 * Result is unspecified if writing outside of the bounds.
		 */
		setDouble(pos: number, v: number): void;
		/**
		 * Store the IEEE single precision value at given position in low endian encoding.
		 * Result is unspecified if writing outside of the bounds.
		 */
		setFloat(pos: number, v: number): void;
		/**
		 * Returns the 16 bit unsigned integer at given position (in low endian encoding).
		 */
		getUInt16(pos: number): number;
		/**
		 * Store the 16 bit unsigned integer at given position (in low endian encoding).
		 */
		setUInt16(pos: number, v: number): void;
		/**
		 * Returns the 32 bit integer at given position (in low endian encoding).
		 */
		getInt32(pos: number): number;
		/**
		 * Store the 32 bit integer at given position (in low endian encoding).
		 */
		setInt32(pos: number, v: number): void;
		/**
		 * Returns the 64 bit integer at given position (in low endian encoding).
		 */
		getInt64(pos: number): haxe._Int64.___Int64;
		/**
		 * Store the 64 bit integer at given position (in low endian encoding).
		 */
		setInt64(pos: number, v: haxe._Int64.___Int64): void;
		getString(pos: number, len: number): string;
		readString(pos: number, len: number): string;
		toString(): string;
		toHex(): string;
		getData(): ArrayBuffer;
		static alloc(length: number): haxe.io.Bytes;
		static ofString(s: string): haxe.io.Bytes;
		static ofData(b: ArrayBuffer): haxe.io.Bytes;
		/**
		 * Read the most efficiently possible the n-th byte of the data.
		 * Behavior when reading outside of the available data is unspecified.
		 */
		static fastGet(b: ArrayBuffer, pos: number): number;
	}
}

export namespace altern.terrain {
	/**
	 * @author Thatcher Ulrich (tu@tulrich.com)
	 * @author Glenn Ko
	 */
	export class HeightMapInfo {
		constructor();
		Data: Int32Array;
		XOrigin: number;
		ZOrigin: number;
		XSize: number;
		ZSize: number;
		RowWidth: number;
		Scale: number;
		getData(ix: number, iz: number): number;
		fillDataWithValue(val: number): void;
		setFixed(val: boolean): void;
		BoxFilterHeightMap(smoothEdges: boolean): void;
		Sample(x: number, z: number): number;
		SampleInd(xi: number, zi: number): number;
		clone(): altern.terrain.HeightMapInfo;
		flatten(val: number): void;
		slopeAlongXY(val: number, multiplier?: number): void;
		slopeAlongY(val: number): void;
		slopeAltAlongY(val: number): void;
		randomise(val: number): void;
		copyData(xStart: number, yStart: number, width: number, height: number, hm: altern.terrain.HeightMapInfo, destX?: number, destY?: number): void;
		setFromBytes(bytes: haxe.io.Bytes, heightMult: number, patchesAcross: number, heightMin?: number, tileSize?: number): void;
		setFlat(numTilesAcross: number, tileSize?: number): void;
		reset(): void;
		paddEdgeDataValues(): void;
		static isBase2(val: number): boolean;
		static createFlat(patchesAcross: number, tileSize?: number): altern.terrain.HeightMapInfo;
		static createFromBytes(x: number, y: number, bytes: haxe.io.Bytes, heightMult: number, patchesAcross: number, heightMin?: number, tileSize?: number): altern.terrain.HeightMapInfo;
	}
}

export namespace altern.terrain {
	/**
	 * ...
	 * @author Glidias
	 */
	export class QuadTreePage extends altern.terrain.QuadChunkCornerData {
		constructor();
		requirements: number;
		heightMap: altern.terrain.HeightMapInfo;
		uvTileSize: number;
		static isBase2(val: number): boolean;
		static create(x: number, y: number, size: number): altern.terrain.QuadTreePage;
	}
}

export namespace altern.terrain {
	/**
	 * ...
	 * @author Glidias
	 */
	export class GeometryResult {
		constructor();
		geometry: util.geom.Geometry;
		indexLookup: Int32Array;
		uvSeg: number;
		edgeChangeVertexIndex: number;
		verticesAcross: number;
		patchSize: number;
		getIndexAtUV(u: number, v: number): number;
		getIndex(x: number, y: number): number;
	}
}

export namespace altern.terrain {
	/**
	 * Striped down class to manage LOD of quadtree displaying in general fashion (3d engine agnostic with hooks for 3d engine to overwrite)
	 * @author Glidias
	 */
	export class TerrainLOD implements altern.ray.IRaycastImpl, altern.terrain.ICuller {
		constructor();
		newly_instantiated: number;
		pool_retrieved: number;
		cached_retrieved: number;
		handedness: number;
		gridPagesVector: altern.terrain.QuadTreePage[];
		tree: altern.terrain.QuadTreePage;
		detail: number;
		setDetail(val: number): void;
		setupUpdateCullingMode(mode: number): void;
		waterLevel: number;
		setUpdateRadius(val: number): void;
		loadSinglePage(page: altern.terrain.QuadTreePage, uvTileSize?: number, requirements?: number, tileSize?: number): void;
		runSinglePage(heightMap: altern.terrain.HeightMapInfo, quadCornerChunk: altern.terrain.QuadTreePage, requirements: number, uvTileSize?: number, tileSize?: number): void;
		collectDraws(camera: util.geom.Vec3): void;
		cullingInFrustum(culling: number, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): number;
		intersectRay(origin: altern.Vector3D, direction: altern.Vector3D, result: altern.Vector3D): altern.Vector3D;
		numCollisionTriangles: number;
		setupCollisionGeometry(sphere: altern.Vector3D, vertices: number[], indices: number[], vi?: number, ii?: number): void;
		calcBoundIntersection(point: altern.Vector3D, origin: altern.Vector3D, direction: altern.Vector3D, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): number;
		static readonly PATCHES_ACROSS: number;
		static readonly NUM_VERTICES: number;
		static readonly PATCHES_SHIFT: number;
		static readonly UV_STEPWISE: number;
		static readonly UV_NORMALIZED: number;
		static PROTO_32: altern.terrain.GeometryResult;
		static readonly CULL_NONE: number;
		static readonly CULL_WATER: number;
		static readonly CULL_FULL: number;
		static installQuadTreePageHeightmap(heightMap: altern.terrain.HeightMapInfo, offsetX?: number, offsetY?: number, tileSize?: number, sampleSize?: number): altern.terrain.QuadTreePage;
	}
}

export namespace altern {
	export class Vector3D implements util.geom.XYZW {
		constructor(x: number, y?: number, z?: number, w?: number);
		get_length(): number;
		get_lengthSquared(): number;
		w: number;
		x: number;
		y: number;
		z: number;
		add(a: altern.Vector3D): altern.Vector3D;
		clone(): altern.Vector3D;
		crossProduct(a: altern.Vector3D): altern.Vector3D;
		decrementBy(a: altern.Vector3D): void;
		dotProduct(a: altern.Vector3D): number;
		equals(toCompare: altern.Vector3D, allFour?: boolean): boolean;
		incrementBy(a: altern.Vector3D): void;
		nearEquals(toCompare: altern.Vector3D, tolerance: number, allFour?: boolean): boolean;
		negate(): void;
		normalize(): number;
		project(): void;
		scaleBy(s: number): void;
		subtract(a: altern.Vector3D): altern.Vector3D;
		toString(): string;
		static angleBetween(a: altern.Vector3D, b: altern.Vector3D): number;
		static distance(pt1: altern.Vector3D, pt2: altern.Vector3D): number;
		static get_X_AXIS(): altern.Vector3D;
		static get_Y_AXIS(): altern.Vector3D;
		static get_Z_AXIS(): altern.Vector3D;
	}
}

export namespace jeash.geom {
	export class Point {
		constructor(inX: number, inY?: number);
		x: number;
		y: number;
		add(v: jeash.geom.Point): jeash.geom.Point;
		clone(): jeash.geom.Point;
		equals(toCompare: jeash.geom.Point): boolean;
		get_length(): number;
		normalize(thickness: number): void;
		offset(dx: number, dy: number): void;
		subtract(v: jeash.geom.Point): jeash.geom.Point;
		static distance(pt1: jeash.geom.Point, pt2: jeash.geom.Point): number;
		static interpolate(pt1: jeash.geom.Point, pt2: jeash.geom.Point, f: number): jeash.geom.Point;
		static polar(len: number, angle: number): jeash.geom.Point;
	}
}

export namespace jeash.geom {
	export class Matrix {
		constructor(in_a: number, in_b?: number, in_c?: number, in_d?: number, in_tx?: number, in_ty?: number);
		a: number;
		b: number;
		c: number;
		d: number;
		tx: number;
		ty: number;
		copyFrom(src: jeash.geom.Matrix): void;
		clone(): jeash.geom.Matrix;
		concat(m: jeash.geom.Matrix): void;
		createBox(scaleX: number, scaleY: number, rotation?: number, tx?: number, ty?: number): void;
		createGradientBox(in_width: number, in_height: number, rotation?: number, in_tx?: number, in_ty?: number): void;
		deltaTransformPoint(point: jeash.geom.Point): jeash.geom.Point;
		identity(): void;
		invert(): jeash.geom.Matrix;
		mult(m: jeash.geom.Matrix): jeash.geom.Matrix;
		rotate(inTheta: number): void;
		scale(inSX: number, inSY: number): void;
		setRotation(inTheta: number, inScale?: number): void;
		setTo(a: number, b: number, c: number, d: number, tx: number, ty: number): void;
		transformPoint(inPos: jeash.geom.Point): jeash.geom.Point;
		translate(inDX: number, inDY: number): void;
		toString(): string;
	}
}

export namespace jeash.geom {
	export class Rectangle {
		constructor(inX: number, inY?: number, inWidth?: number, inHeight?: number);
		x: number;
		y: number;
		width: number;
		height: number;
		get_left(): number;
		set_left(l: number): number;
		get_right(): number;
		set_right(r: number): number;
		get_top(): number;
		set_top(t: number): number;
		get_bottom(): number;
		set_bottom(b: number): number;
		get_topLeft(): jeash.geom.Point;
		set_topLeft(p: jeash.geom.Point): jeash.geom.Point;
		get_size(): jeash.geom.Point;
		set_size(p: jeash.geom.Point): jeash.geom.Point;
		get_bottomRight(): jeash.geom.Point;
		set_bottomRight(p: jeash.geom.Point): jeash.geom.Point;
		clone(): jeash.geom.Rectangle;
		contains(inX: number, inY: number): boolean;
		containsPoint(point: jeash.geom.Point): boolean;
		containsRect(rect: jeash.geom.Rectangle): boolean;
		equals(toCompare: jeash.geom.Rectangle): boolean;
		inflate(dx: number, dy: number): void;
		inflatePoint(point: jeash.geom.Point): void;
		intersection(toIntersect: jeash.geom.Rectangle): jeash.geom.Rectangle;
		intersects(toIntersect: jeash.geom.Rectangle): boolean;
		union(toUnion: jeash.geom.Rectangle): jeash.geom.Rectangle;
		isEmpty(): boolean;
		offset(dx: number, dy: number): void;
		offsetPoint(point: jeash.geom.Point): void;
		setEmpty(): void;
		transform(m: jeash.geom.Matrix): jeash.geom.Rectangle;
		extendBounds(r: jeash.geom.Rectangle): void;
	}
}

export namespace util.geom {
	/**
	 * ...
	 * @author Glenn Ko
	 */
	export class AABBUtils {
		protected constructor();
		static readonly MAX_VALUE: number;
		static readonly THRESHOLD: number;
		static getRect(aabb: components.BoundBox, threshold?: number): jeash.geom.Rectangle;
		static clampMagnitude(mag: number, threshold?: number): number;
		static getString(aabb: components.BoundBox): string;
		static pointInside(aabb: components.BoundBox, pt: util.geom.Vec3): boolean;
		static intersectsEachOther(a: components.BoundBox, b: components.BoundBox): boolean;
		static intersectsBoundValues(a: components.BoundBox, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): boolean;
		static transform(aabb: components.BoundBox, t: components.Transform3D): void;
		static match(aabb: components.BoundBox, refAABB: components.BoundBox): void;
		static setToMax(aabb: components.BoundBox): void;
		static reset(aabb: components.BoundBox): void;
		static expand2(aabb: components.BoundBox, refAABB: components.BoundBox): void;
		static expand(x: number, y: number, z: number, aabb: components.BoundBox): void;
		static expandWithPoint(vec: util.geom.Vec3, aabb: components.BoundBox): void;
		static checkSphere(aabb: components.BoundBox, sphere: altern.Vector3D): boolean;
		static intersectRay(aabb: components.BoundBox, origin: altern.Vector3D, direction: altern.Vector3D): boolean;
	}
}

export namespace util.geom {
	/**
	 * To handle collision scene graph, geometries and transforms
	 * @author Glidias
	 */
	export class GeomCollisionSceneUtil {
		protected constructor();
		/**
		 * @private
		 * Performs calculation of bound box of objects hierarchy branch.
		 */
		static calculateHierarchyBoundBox(object: altern.collisions.CollisionBoundNode, boundBoxSpace?: altern.collisions.CollisionBoundNode, result?: components.BoundBox): components.BoundBox;
		static transformBounds(bounds: components.BoundBox, t: components.Transform3D): void;
		static updateBounds(boundBox: components.BoundBox, tBounds: components.BoundBox): void;
	}
}

export namespace util.geom {
	/**
	 * General utilities to manage 3d geometric data and transforms
	 * @author Glidias
	 */
	export class GeomUtil {
		protected constructor();
		static transformVertices(vertices: number[], t: components.Transform3D, len?: number): void;
		static boundIntersectSphere(sphere: altern.Vector3D, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): boolean;
		static boundIntersectRay(origin: altern.Vector3D, direction: altern.Vector3D, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number, result: altern.Vector3D): boolean;
		static intersectRayTri(result: altern.Vector3D, ox: number, oy: number, oz: number, dx: number, dy: number, dz: number, ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number): boolean;
	}
}

export namespace util.geom {
	export interface ITECollidable extends systems.collisions.ITCollidable, systems.collisions.IECollidable {
	}
}

export namespace util.geom {
	export class Geometry implements altern.culling.IFrustumCollectTri, altern.ray.IRaycastImpl, util.geom.ITECollidable {
		constructor();
		vertices: number[];
		indices: number[];
		numVertices: number;
		numIndices: number;
		setVertices(val: number[]): void;
		setIndices(val: number[]): void;
		collectGeometry(collider: systems.collisions.EllipsoidCollider): void;
		collectGeometryAndTransforms(collider: systems.collisions.EllipsoidCollider, baseTransform: components.Transform3D): void;
		intersectRay(origin: altern.Vector3D, direction: altern.Vector3D, res: altern.Vector3D): altern.Vector3D;
		collectTrisForFrustum(frustum: altern.culling.CullingPlane, culling: number, frustumCorners: altern.Vector3D[], vertices: number[], indices: number[]): void;
		static IDENTITY: components.Transform3D;
	}
}